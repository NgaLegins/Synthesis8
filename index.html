<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glimmer Chaos Minimal</title>
    
    <script src="https://unpkg.com/tone"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            height: 100vh;
            font-family: sans-serif;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        /* Overlay semplificato per il pulsante di avvio */
        #start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            /* Rimossi sfondo e padding per un look minimale */
        }
        /* Stile per il pulsante "Play" grande */
        #start-btn {
            width: 120px;
            height: 120px;
            border-radius: 50%; /* Cerchio perfetto */
            font-size: 50px; /* Icona play grande */
            cursor: pointer;
            background: white;
            border: none;
            transition: background 0.3s, transform 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            padding-left: 8px; /* Correzione ottica per centrare l'icona play */
            color: black;
        }
        #start-btn:hover {
            background: #ddd;
            transform: scale(1.05);
        }
        
        /* Stile aggiornato per la scritta (senza ombra) */
        #subtitle {
            position: fixed;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            
            /* Font Bebas Neue */
            font-family: 'Bebas Neue', sans-serif;
            
            /* Dimensione aumentata */
            font-size: 60px; 
            letter-spacing: 3px;
            
            z-index: 5;
            pointer-events: none;
            
            /* Ombra RIMOSSA */
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <button id="start-btn">&#9658;</button> </div>

    <canvas id="canvas-container"></canvas>
    
    <h2 id="subtitle">YOU ARE THE DRIVING FORCE</h2>

    <script>
        // --- VARIABILI GLOBALI ---
        let isPlaying = false;
        let corruptionLevel = 0; 

        // Audio Components
        let synth, vibrato, distortion, bitCrusher, delay, reverb, loopSequence;

        // Visual Components
        const canvas = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        let circles = []; 

        // --- SETUP INIZIALE ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();


        // --- SETUP AUDIO ---
        async function setupAudio() {
            await Tone.start();
            Tone.Transport.bpm.value = 100; 

            // Synth FM "Glimmer"
            synth = new Tone.FMSynth({
                harmonicity: 2,
                modulationIndex: 3.5,
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 1.2 },
                modulation: { type: "square" },
                modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
            });

            // Catena effetti
            vibrato = new Tone.Vibrato({ frequency: 5, depth: 0 }).toDestination();
            bitCrusher = new Tone.BitCrusher({ bits: 8, wet: 0 }).toDestination();
            distortion = new Tone.Distortion({ distortion: 0, wet: 0 }).toDestination();
            delay = new Tone.PingPongDelay({ delayTime: "8n", feedback: 0.4, wet: 0.3 }).toDestination();
            reverb = new Tone.Reverb({ decay: 5, wet: 0.5 }).toDestination();
            
            await reverb.generate();

            synth.chain(vibrato, bitCrusher, distortion, delay, reverb, Tone.Destination);

            const notes = ["C5", "E5", "G5", "A5", "C6", "D6", "E6", "G6"];
            
            loopSequence = new Tone.Sequence((time, note) => {
                synth.triggerAttackRelease(note, "8n", time);
                Tone.Draw.schedule(() => {
                    visualTrigger();
                }, time);
            }, notes, "4n");

            // --- LOOP CORRUZIONE ---
            Tone.Transport.scheduleRepeat((time) => {
                if (corruptionLevel < 1.0) {
                    corruptionLevel += 0.015; // Velocità di incremento
                }
                applyCorruption(corruptionLevel);
            }, "1m");
        }

        function applyCorruption(level) {
            let distCurve = Math.pow(level, 0.8); 

            vibrato.depth.rampTo(distCurve * 0.9, 1); 
            vibrato.frequency.rampTo(5 + distCurve * 15, 1);
            
            distortion.distortion = distCurve * 0.9;
            distortion.wet.rampTo(distCurve * 0.8, 1);
            
            const newBits = 8 - (distCurve * 6); 
            bitCrusher.bits = Math.max(1.5, newBits); 
            bitCrusher.wet.rampTo(distCurve * 0.7, 1);
            
            reverb.wet.rampTo(0.5 - (level * 0.4), 1);
            delay.wet.rampTo(0.3 - (level * 0.2), 1);
            Tone.Transport.bpm.rampTo(100 + (level * 80), 1); 
            synth.envelope.release = 1.2 - (level * 1.1);
        }


        // --- SETUP VISIVO E MITOSI ---

        function createCircle(x, y, radius, state = 'normal') {
            return {
                x: x, 
                y: y, 
                radius: Math.max(4, radius),
                pulseScale: 1.0, 
                state: state, 
                splitProgress: 0.0,
                splitAngle: Math.random() * Math.PI * 2 
            };
        }

        function setupVisuals() {
            circles.push(createCircle(
                canvas.width / 2, 
                canvas.height / 2, 
                Math.min(canvas.width, canvas.height) / 5 
            ));
        }

        function visualTrigger() {
            // Intensità pulsazione dinamica (aumenta con il caos)
            const currentPulseStrength = 1.05 + (corruptionLevel * 0.35);

            circles.forEach(c => {
                c.pulseScale = currentPulseStrength; 
            });

            // Logica Mitosi
            let candidates = circles.filter(c => c.state === 'normal');

            if (candidates.length > 0 && circles.length < 800) { 
                
                candidates.sort((a, b) => b.radius - a.radius);
                const indexToSplit = Math.floor(Math.random() * Math.min(candidates.length, 5));
                const parent = candidates[indexToSplit];
                
                parent.state = 'splitting';
                parent.splitProgress = 0;
                parent.targetChildRadius = parent.radius * 0.85; 
            }
        }

        function drawLoop() {
            requestAnimationFrame(drawLoop);
            if (!isPlaying) return;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const baseOpacity = 1 - (corruptionLevel * 0.2); 
            ctx.fillStyle = 'white';

            for (let i = circles.length - 1; i >= 0; i--) {
                let circle = circles[i];

                // Ritorno elastico
                circle.pulseScale += (1.0 - circle.pulseScale) * 0.1;

                if (circle.state === 'splitting') {
                    circle.splitProgress += 0.03 * (1 + corruptionLevel * 2);

                    if (circle.splitProgress >= 1.0) {
                        circles.splice(i, 1); 

                        const separationDist = circle.radius * 1.3; 
                        
                        let offsetX = Math.cos(circle.splitAngle) * separationDist;
                        let offsetY = Math.sin(circle.splitAngle) * separationDist;

                        circles.push(createCircle(circle.x + offsetX, circle.y + offsetY, circle.targetChildRadius));
                        circles.push(createCircle(circle.x - offsetX, circle.y - offsetY, circle.targetChildRadius));
                        
                        continue;
                    }
                }

                ctx.globalAlpha = baseOpacity * (0.8 + Math.random()*0.2);

                let currentDrawRadius = circle.radius * circle.pulseScale;

                if (circle.state === 'normal') {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, currentDrawRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                else if (circle.state === 'splitting') {
                    let evolvingRadius = circle.radius + (circle.targetChildRadius - circle.radius) * circle.splitProgress;
                    evolvingRadius *= circle.pulseScale;

                    let currentSeparation = (circle.radius * 1.3) * circle.splitProgress;
                    let dx = Math.cos(circle.splitAngle) * currentSeparation;
                    let dy = Math.sin(circle.splitAngle) * currentSeparation;

                    ctx.beginPath();
                    ctx.arc(circle.x + dx, circle.y + dy, evolvingRadius, 0, Math.PI * 2);
                    ctx.arc(circle.x - dx, circle.y - dy, evolvingRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0; 
        }

        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            if (!isPlaying) {
                await setupAudio();
                setupVisuals();
                Tone.Transport.start();
                loopSequence.start(0);
                isPlaying = true;
                drawLoop();
            }
        });

    </script>
</body>
</html>
